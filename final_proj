## WebPage
# WebPage A: Super Foods        Apples, Bananas, Broccoli, Cabbage, Kumquats, Strawberries
# WebPage B: Magic Fruits       Oranges, Plums, Coconuts, Kumquats, Blueberries, Cherries, Strawberries
# WebPage C: Sam's Produce      Lettuce, Spinach, Bananas, Blackberries, Peas, Strawberries
# WebPage D: Corner Market      Oranges, Onions, Celery, Kumquats, Corn, Radishes
# WebPage E: Eli's Organic      Pineapples, Plums, Corn, Cherries, Broccoli, Peas, Strawberries
# WebPage F: Crunchy Munchies   Lettuce, Onions, Coconuts, Spinach, Peas, Strawberries
# WebPage G: HomeGrown          Apples, Onions, Broccoli, Corn, Cabbage, Peas
# WebPage H: Berry Palace       Plums, Blueberries, Raspberries, Blackberries, Strawberries
# WebPage I: Cheap Eats         Apples, Cucumbers, Carrots, Spinach, Corn, Black Beans, Cabbage
# WebPage J: Salads 'R Us       Mushrooms, Carrots, Lettuce, Radishes, Peppers, Broccoli, Spinach
# WebPage K: World of Produce   Carrots, Lettuce, Celery, Onions, Cabbage, Peas
# WebPage L: Good Eats          Broccoli, Cabbage, Carrots, Spinach, Corn, Peas

## Keywords
# T1: Apples
# T2: Bananas
# T3: Broccoli
# T4: Blueberries
# T5: Blackberries
# T6: Black Beans
# T7: Cabbage
# T8: Carrots
# T9: Celery
# T10: Cherries
# T11: Coconuts
# T12: Corn
# T13: Cucumbers
# T14: Kumquats
# T15: Lettuce
# T16: Mushrooms
# T17: Onions
# T18: Oranges
# T19: Peas
# T20: Peppers
# T21: Pineapples
# T22: Plums
# T23: Radishes
# T24: Raspberries
# T25: Spinach
# T26: Strawberries

import numpy as np
from numpy import linalg as LA

# Construct the raw matrix G
G = np.array([
    # A, B, C, D, E, F, G, H, I, J, K, L
    [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], # A
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], # B
    [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], # C
    [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], # D
    [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], # E
    [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], # F
    [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1], # G
    [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0], # H
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], # I
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], # J
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], # K
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0] # L
])

# Normalize the adjacency matrix to get the google matrix G
row_sums = G.sum(axis = 1, keepdims = True)
G = np.divide(G, row_sums, where = row_sums != 0)

# Handling dangling nodes (rows with sum 0)
dangling_nodes = row_sums.flatten() == 0
G[dangling_nodes, :] = 1 / len(G)

# Ensure all rows add up to 1 or 0
row_sums = G.sum(axis = 1)
print("Row sums after normalization and handling dangling nodes: ", row_sums)

# Do eigenvalue decomposition
eig_val, eig_vec = LA.eig(G.T)
print("Eigenvalues:\n", eig_val)
print("Eigenvectors:\n", eig_vec)

# Find the eigenvector corresponding to the eigenvalue 1
tolerance = 1e-8
idx = np.isclose(eig_val, 1, atol = tolerance)
principal_eigvec = eig_vec[:, idx].flatten().real

if principal_eigvec.size == 0:
    print("No eigenvector exactly equals 1 within the given tolerance.")
    max_idx = np.argmax(eig_val)
    principal_eigvec = eig_vec[:, idx].flatten().real

if np.all(principal_eigvec >= 0):
    print("Principal Eigenvector (PageRank Scores):\n", principal_eigvec)
else:
    print("The eigenvector corresponding to the eigenvalue 1 has negative entries.")
